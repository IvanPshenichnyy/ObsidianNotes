24.12.2009

# Процесс исполнения встроенного языка 1С:Предприятия

Раздел содержит пояснения к понятию "процесс исполнения встроенного языка 1С:Предприятия" и действиям платформы, выполняемым при его начале и завершении: с транзакциями, с блокировками данных для редактирования, с повторно используемыми значениями, с утечками памяти.

## Что такое "процесс исполнения встроенного языка 1С:Предприятия"

**Процесс выполнения встроенного языка** (далее в этом разделе - **процесс**) представляет собой исполнение платформой 1С:Предприятия кода конфигурации на встроенном языке.

Процесс начинается, когда платформа 1С:Предприятия или операционная система создает объект 1С:Предприятия, имеющий модуль с непустым телом, или вызывает метод модуля. После достижения конца тела модуля или при возврате из метода модуля, вызванного платформой 1С:Предприятия или операционной системой, процесс выполнения встроенного языка заканчивается.

Например:

- При запуске клиентского приложения 1С:Предприятия, если конфигурация имеет непустой модуль приложения (модуль обычного приложения, модуль внешнего соединения, модуль управляемого приложения), начинается процесс исполнения тела модуля приложения. Тело модуля приложения выполняется, включая все, что из него вызывается. После этого процесс исполнения тела модуля приложения заканчивается.
- Процесс начинается при вызове платформой обработчиков событий модуля приложения (**ПередНачаломРаботыСистемы**, **ПередЗавершениемРаботыСистемы** и т. д.) или обработчиков ожидания (установленных методом **ПодключитьОбработчикОжидания**) и заканчивается при окончании выполнения соответствующего обработчика.
- Процесс начинается, если платформа вызывает обработчик интерактивного действия в форме или элементе управления (**ПриАктивизацииСтроки**, **ПриАктивизацииКолонки** и т. д.) и заканчивается при окончании выполнения соответствующего обработчика.
- Процесс начинается, если в результате интерактивного действия платформа вызывает обработчик события, определенного в модуле объекта (**ПередЗаписью**, **ПриЗаписи** и т. д.), и заканчивается при окончании выполнения соответствующего обработчика.
- Процесс начинается при начале выполнения серверного метода, непосредственно вызванного с клиента, и заканчивается при возврате управления из этого метода клиенту.
- Процесс начинается при первом вызове метода встроенного языка через COM и заканчивается при последнем возврате управления из этого метода.

Важно, что если стек вызовов методов встроенного языка сложный и включает многократные переходы между операционной системой, платформой и встроенным языком, то процесс начинается только при первом переходе из операционной системы или платформы во встроенный язык и заканчивается при последнем переходе из встроенного языка в платформу или операционную систему.

Исключением является случай, когда выполнение встроенного языка приостановлено отладчиком и отладчик выполняет вычисление выражения. В этом случае для вычисления выражения начинается новый процесс. После вычисления выражения этот процесс заканчивается.

При начале и окончании процесса платформа выполняет ряд неявных действий, которые могут оказать влияние на работу конфигурации.

## Транзакции

Многие операции, выполняемые конфигурациями, требуют согласованного чтения/изменения данных. Для этих целей используется механизм транзакций. Транзакции могут начинаться и заканчиваться как неявно объектами 1С:Предприятия (например, при записи или проведении документов), так и явно методами глобального контекста **НачатьТранзакцию()**, **ЗафиксироватьТранзакцию()** и **ОтменитьТранзакцию()**. Начало транзакции (неявно или при помощи **НачатьТранзакцию()**) может быть выполнено многократно. Фактическое начало транзакции происходит только при первом выполнении начала транзакции, а все прочие приводят к увеличению значения счетчика транзакции. Выполнение окончания транзакции (неявно или при помощи **ЗафиксироватьТранзакцию()**/**ОтменитьТранзакцию()**) приводит к уменьшению значения счетчика транзакции. Только последнее выполнение окончания транзакции приводит к ее фактическому завершению.

Подробнее можно прочитать в статье "[Ошибки базы данных и транзакции](https://its.1c.ru/db/metod8dev/content/2313/hdoc)".

Важно, что значение счетчика транзакции сохраняется при начале процесса.

В течение процесса значение счетчика транзакции не может стать меньше сохраненного значения. Если при выполнении метода **ЗафиксироватьТранзакцию()** или **ОтменитьТранзакцию()** значение счетчика транзакции должно было стать меньше, чем сохраненное значение счетчика, то возникает исключение "Транзакция не открыта".

При окончании процесса, если текущее значение счетчика транзакции больше сохраненного значения, то платформа неявно выполняет **ОтменитьТранзакцию()** столько раз, сколько необходимо, чтобы значения стали равны.

## Блокировки данных для редактирования

Блокировки данных для редактирования управляются методами глобального контекста **ЗаблокироватьДанныеДляРедактирования()** и **РазблокироватьДанныеДляРедактирования()**. Если при вызове метода **ЗаблокироватьДанныеДляРедактирования()** не указано значение параметра **ИдентификаторФормы**, то при окончании процесса установленная блокировка снимается платформой неявно.

## Повторно используемые значения

Общие модули с повторно используемыми значениями можно использовать для сохранения значений часто используемых данных. Если для общего модуля установлено значение "На время вызова" свойства "Повторное использование возвращаемых значений", то хранимые значения будут неявно удаляться платформой при окончании процесса.

## Утечки памяти

В технологическом журнале предусмотрена возможность отслеживания утечек памяти при выполнении заданных участков кода конфигурации. Важным частным случаем контролируемого участка кода конфигурации является процесс. Если в конфигурационном файле технологического журнала контроль утечек памяти задан следующим элементом leaks:

Копировать в буфер обмена

<leaks Collect=1>
  <point Call="client"/>
  <point Сall="server"/>
</leaks>

то в технологический журнал будет выведена информация об объектах, которые были созданы, но не были освобождены между началом и окончанием процесса на сервере (<point Сall="server"/>) и на клиенте (<point Call="client"/>).